/*
 * generated by Xtext 2.25.0
 */
package xtext.factoryLang.shortDSL.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.factoryLang.shortDSL.services.ShortDSLGrammarAccess;
import xtext.factoryLang.shortDSL.shortDSL.Camera;
import xtext.factoryLang.shortDSL.shortDSL.CameraColor;
import xtext.factoryLang.shortDSL.shortDSL.ColorValueS;
import xtext.factoryLang.shortDSL.shortDSL.ConditionDevice;
import xtext.factoryLang.shortDSL.shortDSL.ConditionSlot;
import xtext.factoryLang.shortDSL.shortDSL.ConditionVariable;
import xtext.factoryLang.shortDSL.shortDSL.ConfigurationS;
import xtext.factoryLang.shortDSL.shortDSL.Crane;
import xtext.factoryLang.shortDSL.shortDSL.CraneAction;
import xtext.factoryLang.shortDSL.shortDSL.CraneZone;
import xtext.factoryLang.shortDSL.shortDSL.DSLLong;
import xtext.factoryLang.shortDSL.shortDSL.DSLShort;
import xtext.factoryLang.shortDSL.shortDSL.DSLTypeValue;
import xtext.factoryLang.shortDSL.shortDSL.DeviceValueS;
import xtext.factoryLang.shortDSL.shortDSL.Disk;
import xtext.factoryLang.shortDSL.shortDSL.DiskHandlingS;
import xtext.factoryLang.shortDSL.shortDSL.DiskSlotStateValueS;
import xtext.factoryLang.shortDSL.shortDSL.DiskStateValueS;
import xtext.factoryLang.shortDSL.shortDSL.DiskZone;
import xtext.factoryLang.shortDSL.shortDSL.Logging;
import xtext.factoryLang.shortDSL.shortDSL.LoopSlot;
import xtext.factoryLang.shortDSL.shortDSL.LoopVariable;
import xtext.factoryLang.shortDSL.shortDSL.MarkCameraValue;
import xtext.factoryLang.shortDSL.shortDSL.MarkVariableValue;
import xtext.factoryLang.shortDSL.shortDSL.Model;
import xtext.factoryLang.shortDSL.shortDSL.MoveAnySlot;
import xtext.factoryLang.shortDSL.shortDSL.MoveCrane;
import xtext.factoryLang.shortDSL.shortDSL.MoveDisk;
import xtext.factoryLang.shortDSL.shortDSL.NumberS;
import xtext.factoryLang.shortDSL.shortDSL.OrdinaryVariable;
import xtext.factoryLang.shortDSL.shortDSL.ShortDSLPackage;
import xtext.factoryLang.shortDSL.shortDSL.SlotVariable;
import xtext.factoryLang.shortDSL.shortDSL.ValueSlotS;
import xtext.factoryLang.shortDSL.shortDSL.VariableValueS;

@SuppressWarnings("all")
public class ShortDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ShortDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ShortDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ShortDSLPackage.CAMERA:
				sequence_CameraS(context, (Camera) semanticObject); 
				return; 
			case ShortDSLPackage.CAMERA_COLOR:
				sequence_CameraColorS(context, (CameraColor) semanticObject); 
				return; 
			case ShortDSLPackage.COLOR_VALUE_S:
				sequence_ColorValueS(context, (ColorValueS) semanticObject); 
				return; 
			case ShortDSLPackage.CONDITION_DEVICE:
				sequence_ConditionDeviceS(context, (ConditionDevice) semanticObject); 
				return; 
			case ShortDSLPackage.CONDITION_SLOT:
				sequence_ConditionSlotS(context, (ConditionSlot) semanticObject); 
				return; 
			case ShortDSLPackage.CONDITION_VARIABLE:
				sequence_ConditionVariableS(context, (ConditionVariable) semanticObject); 
				return; 
			case ShortDSLPackage.CONFIGURATION_S:
				sequence_ConfigurationS(context, (ConfigurationS) semanticObject); 
				return; 
			case ShortDSLPackage.CRANE:
				sequence_CraneS(context, (Crane) semanticObject); 
				return; 
			case ShortDSLPackage.CRANE_ACTION:
				sequence_CraneActionS(context, (CraneAction) semanticObject); 
				return; 
			case ShortDSLPackage.CRANE_ZONE:
				sequence_CraneZoneS(context, (CraneZone) semanticObject); 
				return; 
			case ShortDSLPackage.DSL_LONG:
				sequence_DSLLong(context, (DSLLong) semanticObject); 
				return; 
			case ShortDSLPackage.DSL_SHORT:
				sequence_DSLShort(context, (DSLShort) semanticObject); 
				return; 
			case ShortDSLPackage.DSL_TYPE_VALUE:
				sequence_DSLTypeValue(context, (DSLTypeValue) semanticObject); 
				return; 
			case ShortDSLPackage.DEVICE_VALUE_S:
				sequence_DeviceValueS(context, (DeviceValueS) semanticObject); 
				return; 
			case ShortDSLPackage.DISK:
				sequence_DiskS(context, (Disk) semanticObject); 
				return; 
			case ShortDSLPackage.DISK_HANDLING_S:
				sequence_DiskHandlingS(context, (DiskHandlingS) semanticObject); 
				return; 
			case ShortDSLPackage.DISK_SLOT_STATE_VALUE_S:
				sequence_DiskSlotStateValueS(context, (DiskSlotStateValueS) semanticObject); 
				return; 
			case ShortDSLPackage.DISK_STATE_VALUE_S:
				sequence_DiskStateValueS(context, (DiskStateValueS) semanticObject); 
				return; 
			case ShortDSLPackage.DISK_ZONE:
				sequence_DiskZoneS(context, (DiskZone) semanticObject); 
				return; 
			case ShortDSLPackage.LOGGING:
				sequence_LoggingS(context, (Logging) semanticObject); 
				return; 
			case ShortDSLPackage.LOOP_SLOT:
				sequence_LoopSlotS(context, (LoopSlot) semanticObject); 
				return; 
			case ShortDSLPackage.LOOP_VARIABLE:
				sequence_LoopVariableS(context, (LoopVariable) semanticObject); 
				return; 
			case ShortDSLPackage.MARK_CAMERA_VALUE:
				sequence_MarkCameraValueS(context, (MarkCameraValue) semanticObject); 
				return; 
			case ShortDSLPackage.MARK_VARIABLE_VALUE:
				sequence_MarkVariableValueS(context, (MarkVariableValue) semanticObject); 
				return; 
			case ShortDSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ShortDSLPackage.MOVE_ANY_SLOT:
				sequence_MoveAnySlotS(context, (MoveAnySlot) semanticObject); 
				return; 
			case ShortDSLPackage.MOVE_CRANE:
				sequence_MoveCraneS(context, (MoveCrane) semanticObject); 
				return; 
			case ShortDSLPackage.MOVE_DISK:
				sequence_MoveDiskS(context, (MoveDisk) semanticObject); 
				return; 
			case ShortDSLPackage.NUMBER_S:
				sequence_NumberS(context, (NumberS) semanticObject); 
				return; 
			case ShortDSLPackage.ORDINARY_VARIABLE:
				sequence_OrdinaryVariableS(context, (OrdinaryVariable) semanticObject); 
				return; 
			case ShortDSLPackage.SLOT_VARIABLE:
				sequence_SlotVariableS(context, (SlotVariable) semanticObject); 
				return; 
			case ShortDSLPackage.VALUE_SLOT_S:
				sequence_ValueSlotS(context, (ValueSlotS) semanticObject); 
				return; 
			case ShortDSLPackage.VARIABLE_VALUE_S:
				sequence_VariableValueS(context, (VariableValueS) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CameraColorS returns CameraColor
	 *
	 * Constraint:
	 *     color=COLOR_S
	 */
	protected void sequence_CameraColorS(ISerializationContext context, CameraColor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.CAMERA_COLOR__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.CAMERA_COLOR__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCameraColorSAccess().getColorCOLOR_SEnumRuleCall_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeviceS returns Camera
	 *     CameraS returns Camera
	 *
	 * Constraint:
	 *     (name=ID logging=LoggingS? targets+=CameraColorS+)
	 */
	protected void sequence_CameraS(ISerializationContext context, Camera semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColorValueS returns ColorValueS
	 *
	 * Constraint:
	 *     value=COLOR_S
	 */
	protected void sequence_ColorValueS(ISerializationContext context, ColorValueS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.COLOR_VALUE_S__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.COLOR_VALUE_S__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorValueSAccess().getValueCOLOR_SEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns ConditionDevice
	 *     ConditionS returns ConditionDevice
	 *     ConditionDeviceS returns ConditionDevice
	 *
	 * Constraint:
	 *     (device=[DeviceS|ID] comparisonOperator=COMPARISON_OPERATOR_S deviceValue=DeviceValueS statements+=StatementS*)
	 */
	protected void sequence_ConditionDeviceS(ISerializationContext context, ConditionDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns ConditionSlot
	 *     ConditionS returns ConditionSlot
	 *     ConditionSlotS returns ConditionSlot
	 *
	 * Constraint:
	 *     (variable=[SlotVariable|ID] comparisonOperator=COMPARISON_OPERATOR_S slotValue=ValueSlotS statements+=StatementS*)
	 */
	protected void sequence_ConditionSlotS(ISerializationContext context, ConditionSlot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns ConditionVariable
	 *     ConditionS returns ConditionVariable
	 *     ConditionVariableS returns ConditionVariable
	 *
	 * Constraint:
	 *     (variable=[OrdinaryVariable|ID] comparisonOperator=COMPARISON_OPERATOR_S variableValue=VariableValueS statements+=StatementS*)
	 */
	protected void sequence_ConditionVariableS(ISerializationContext context, ConditionVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationS returns ConfigurationS
	 *
	 * Constraint:
	 *     devices+=DeviceS+
	 */
	protected void sequence_ConfigurationS(ISerializationContext context, ConfigurationS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns CraneAction
	 *     CraneActionS returns CraneAction
	 *
	 * Constraint:
	 *     {CraneAction}
	 */
	protected void sequence_CraneActionS(ISerializationContext context, CraneAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeviceS returns Crane
	 *     CraneS returns Crane
	 *
	 * Constraint:
	 *     (name=ID logging=LoggingS? targets+=CraneZoneS+)
	 */
	protected void sequence_CraneS(ISerializationContext context, Crane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CraneZoneS returns CraneZone
	 *
	 * Constraint:
	 *     (name=ID zoneValue=INT)
	 */
	protected void sequence_CraneZoneS(ISerializationContext context, CraneZone semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.CRANE_ZONE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.CRANE_ZONE__NAME));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.CRANE_ZONE__ZONE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.CRANE_ZONE__ZONE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCraneZoneSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCraneZoneSAccess().getZoneValueINTTerminalRuleCall_3_0(), semanticObject.getZoneValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLProgram returns DSLLong
	 *     DSLLong returns DSLLong
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLLong(ISerializationContext context, DSLLong semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DSL_LONG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DSL_LONG__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLLongAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLProgram returns DSLShort
	 *     DSLShort returns DSLShort
	 *
	 * Constraint:
	 *     (configuration=ConfigurationS diskHandlings+=DiskHandlingS*)
	 */
	protected void sequence_DSLShort(ISerializationContext context, DSLShort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLTypeValue returns DSLTypeValue
	 *
	 * Constraint:
	 *     value=DSL_TYPE_ENUM
	 */
	protected void sequence_DSLTypeValue(ISerializationContext context, DSLTypeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DSL_TYPE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DSL_TYPE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLTypeValueAccess().getValueDSL_TYPE_ENUMEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeviceValueS returns DeviceValueS
	 *
	 * Constraint:
	 *     (value=DiskStateValueS | value=ColorValueS | configurationValue=[ConfigurationValueS|ID])
	 */
	protected void sequence_DeviceValueS(ISerializationContext context, DeviceValueS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiskHandlingS returns DiskHandlingS
	 *
	 * Constraint:
	 *     (disk=[Disk|ID] statements+=StatementS+)
	 */
	protected void sequence_DiskHandlingS(ISerializationContext context, DiskHandlingS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeviceS returns Disk
	 *     DiskS returns Disk
	 *
	 * Constraint:
	 *     (name=ID nSlots=INT logging=LoggingS? targets+=DiskZoneS+)
	 */
	protected void sequence_DiskS(ISerializationContext context, Disk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiskSlotStateValueS returns DiskSlotStateValueS
	 *
	 * Constraint:
	 *     value=DISK_SLOT_STATES_S
	 */
	protected void sequence_DiskSlotStateValueS(ISerializationContext context, DiskSlotStateValueS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DISK_SLOT_STATE_VALUE_S__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DISK_SLOT_STATE_VALUE_S__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiskSlotStateValueSAccess().getValueDISK_SLOT_STATES_SEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DiskStateValueS returns DiskStateValueS
	 *
	 * Constraint:
	 *     value=DISK_STATES_S
	 */
	protected void sequence_DiskStateValueS(ISerializationContext context, DiskStateValueS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DISK_STATE_VALUE_S__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DISK_STATE_VALUE_S__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiskStateValueSAccess().getValueDISK_STATES_SEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DiskZoneS returns DiskZone
	 *
	 * Constraint:
	 *     (name=ID slot=INT)
	 */
	protected void sequence_DiskZoneS(ISerializationContext context, DiskZone semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DISK_ZONE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DISK_ZONE__NAME));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.DISK_ZONE__SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.DISK_ZONE__SLOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiskZoneSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDiskZoneSAccess().getSlotINTTerminalRuleCall_3_0(), semanticObject.getSlot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoggingS returns Logging
	 *
	 * Constraint:
	 *     {Logging}
	 */
	protected void sequence_LoggingS(ISerializationContext context, Logging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns LoopSlot
	 *     LoopS returns LoopSlot
	 *     LoopSlotS returns LoopSlot
	 *
	 * Constraint:
	 *     (slotVariable=SlotVariableS comparisonOperator=COMPARISON_OPERATOR_S slotState=DiskSlotStateValueS statements+=StatementS*)
	 */
	protected void sequence_LoopSlotS(ISerializationContext context, LoopSlot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns LoopVariable
	 *     LoopS returns LoopVariable
	 *     LoopVariableS returns LoopVariable
	 *
	 * Constraint:
	 *     (ordinaryVariable=OrdinaryVariableS comparisonOperator=COMPARISON_OPERATOR_S slotState=DiskSlotStateValueS statements+=StatementS*)
	 */
	protected void sequence_LoopVariableS(ISerializationContext context, LoopVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns MarkCameraValue
	 *     MarkS returns MarkCameraValue
	 *     MarkCameraValueS returns MarkCameraValue
	 *
	 * Constraint:
	 *     (camera=[Camera|ID] variable=OrdinaryVariableS)
	 */
	protected void sequence_MarkCameraValueS(ISerializationContext context, MarkCameraValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MARK_CAMERA_VALUE__CAMERA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MARK_CAMERA_VALUE__CAMERA));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MARK_CAMERA_VALUE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MARK_CAMERA_VALUE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMarkCameraValueSAccess().getCameraCameraIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MARK_CAMERA_VALUE__CAMERA, false));
		feeder.accept(grammarAccess.getMarkCameraValueSAccess().getVariableOrdinaryVariableSParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns MarkVariableValue
	 *     MarkS returns MarkVariableValue
	 *     MarkVariableValueS returns MarkVariableValue
	 *
	 * Constraint:
	 *     (variable=[VariableS|ID] value=ValueSlotS (time=INT unit=TIME_UNIT_S)?)
	 */
	protected void sequence_MarkVariableValueS(ISerializationContext context, MarkVariableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (dslType=DSLTypeValue dslProgram=DSLProgram)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MODEL__DSL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MODEL__DSL_TYPE));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MODEL__DSL_PROGRAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MODEL__DSL_PROGRAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getDslTypeDSLTypeValueParserRuleCall_1_0(), semanticObject.getDslType());
		feeder.accept(grammarAccess.getModelAccess().getDslProgramDSLProgramParserRuleCall_3_0(), semanticObject.getDslProgram());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns MoveAnySlot
	 *     MoveS returns MoveAnySlot
	 *     MoveAnySlotS returns MoveAnySlot
	 *
	 * Constraint:
	 *     (state=DiskSlotStateValueS anySlot=SlotVariableS zone=[DiskZone|ID])
	 */
	protected void sequence_MoveAnySlotS(ISerializationContext context, MoveAnySlot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__STATE));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__ANY_SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__ANY_SLOT));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__ZONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_ANY_SLOT__ZONE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveAnySlotSAccess().getStateDiskSlotStateValueSParserRuleCall_1_0(), semanticObject.getState());
		feeder.accept(grammarAccess.getMoveAnySlotSAccess().getAnySlotSlotVariableSParserRuleCall_2_0(), semanticObject.getAnySlot());
		feeder.accept(grammarAccess.getMoveAnySlotSAccess().getZoneDiskZoneIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MOVE_ANY_SLOT__ZONE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns MoveCrane
	 *     MoveS returns MoveCrane
	 *     MoveCraneS returns MoveCrane
	 *
	 * Constraint:
	 *     (crane=[Crane|ID] action=CraneActionS zone=[CraneZone|ID])
	 */
	protected void sequence_MoveCraneS(ISerializationContext context, MoveCrane semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__CRANE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__CRANE));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__ACTION));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__ZONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_CRANE__ZONE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveCraneSAccess().getCraneCraneIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MOVE_CRANE__CRANE, false));
		feeder.accept(grammarAccess.getMoveCraneSAccess().getActionCraneActionSParserRuleCall_2_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getMoveCraneSAccess().getZoneCraneZoneIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MOVE_CRANE__ZONE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementS returns MoveDisk
	 *     MoveS returns MoveDisk
	 *     MoveDiskS returns MoveDisk
	 *
	 * Constraint:
	 *     (slot=[SlotVariable|ID] zone=[DiskZone|ID])
	 */
	protected void sequence_MoveDiskS(ISerializationContext context, MoveDisk semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_DISK__SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_DISK__SLOT));
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.MOVE_DISK__ZONE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.MOVE_DISK__ZONE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveDiskSAccess().getSlotSlotVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MOVE_DISK__SLOT, false));
		feeder.accept(grammarAccess.getMoveDiskSAccess().getZoneDiskZoneIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ShortDSLPackage.Literals.MOVE_DISK__ZONE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumberS returns NumberS
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberS(ISerializationContext context, NumberS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.NUMBER_S__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.NUMBER_S__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberSAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableS returns OrdinaryVariable
	 *     OrdinaryVariableS returns OrdinaryVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_OrdinaryVariableS(ISerializationContext context, OrdinaryVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.VARIABLE_S__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.VARIABLE_S__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrdinaryVariableSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableS returns SlotVariable
	 *     SlotVariableS returns SlotVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SlotVariableS(ISerializationContext context, SlotVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ShortDSLPackage.Literals.VARIABLE_S__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ShortDSLPackage.Literals.VARIABLE_S__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSlotVariableSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueSlotS returns ValueSlotS
	 *
	 * Constraint:
	 *     (value=DiskSlotStateValueS | value=ColorValueS)
	 */
	protected void sequence_ValueSlotS(ISerializationContext context, ValueSlotS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableValueS returns VariableValueS
	 *
	 * Constraint:
	 *     (value=DiskSlotStateValueS | value=ColorValueS | value=NumberS | value=DiskStateValueS | ref=[VariableS|ID])
	 */
	protected void sequence_VariableValueS(ISerializationContext context, VariableValueS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
