/*
 * generated by Xtext 2.25.0
 */
package xtext.factoryLang.shortDSL.validation

import org.eclipse.xtext.validation.Check
import xtext.factoryLang.shortDSL.shortDSL.CraneZone
import xtext.factoryLang.shortDSL.shortDSL.ShortDSLPackage.Literals
import xtext.factoryLang.shortDSL.shortDSL.DiskZone
import org.eclipse.xtext.EcoreUtil2
import xtext.factoryLang.shortDSL.shortDSL.Disk
import xtext.factoryLang.shortDSL.shortDSL.MarkVariableValue
import xtext.factoryLang.shortDSL.shortDSL.ConditionDevice
import xtext.factoryLang.shortDSL.shortDSL.Crane
import xtext.factoryLang.shortDSL.shortDSL.Camera
import xtext.factoryLang.shortDSL.shortDSL.DiskStateValueS
import xtext.factoryLang.shortDSL.shortDSL.ColorValueS
import xtext.factoryLang.shortDSL.shortDSL.Model
import xtext.factoryLang.shortDSL.shortDSL.DSL_TYPE_ENUM
import xtext.factoryLang.shortDSL.shortDSL.DSLLong
import xtext.factoryLang.shortDSL.shortDSL.DSLShort
import xtext.factoryLang.shortDSL.shortDSL.DSLProgram
import xtext.factoryLang.shortDSL.shortDSL.TIME_UNIT_S
import xtext.factoryLang.shortDSL.shortDSL.DiskSlotStateValueS
import xtext.factoryLang.shortDSL.shortDSL.ConditionVariable
import xtext.factoryLang.shortDSL.shortDSL.OrdinaryVariable
import xtext.factoryLang.shortDSL.shortDSL.SlotVariable

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ShortDSLValidator extends AbstractShortDSLValidator {
	
	public static val INVALID_VALUE = 'invalidValue'
	
	@Check
	def checkDSLType(Model model) {
		if (!model.eIsSet(Literals.MODEL__DSL_TYPE)) {
			error('Please specify dsl type: ' + DSL_TYPE_ENUM.LONG + ', ' + DSL_TYPE_ENUM.SHORT,
				Literals.MODEL__DSL_TYPE, INVALID_VALUE)
			return
		}
		
		val dslType = model.dslType
		val dslTypeValue = dslType.value
		val dslProgram = model.dslProgram as DSLProgram
		
		if (dslTypeValue == DSL_TYPE_ENUM.LONG) {
			if (dslProgram instanceof DSLShort) {
				error('Wrong dsl syntax - use syntax of long dsl or switch to short dsl',
					Literals.MODEL__DSL_TYPE, INVALID_VALUE)
			}
		}
		else {
			if (dslProgram instanceof DSLLong) {
				error('Wrong dsl syntax - use syntax of short dsl or switch to long dsl',
					Literals.MODEL__DSL_TYPE, INVALID_VALUE)
			}
		}
	}
	
	@Check
	def checkCraneZone(CraneZone zone) {
		if (!(zone.zoneValue>= 0 && zone.zoneValue <= 359)) {
			error('Degree value should be between 0 and 359 degrees (inclusive)',
				Literals.CRANE_ZONE__ZONE_VALUE, INVALID_VALUE)
		}
	}

	@Check
	def checkDiskZone(DiskZone zone) {
		val disk = EcoreUtil2.getContainerOfType(zone, Disk) as Disk
		val nSlots = disk.NSlots

		if (!(zone.slot> 0 && zone.slot <= nSlots)) {
			error('''Slot must be within available slots (1-«nSlots»)''', Literals.DISK_ZONE__SLOT,
				INVALID_VALUE)
		}
	}

	@Check
	def checkMarkVariableValue(MarkVariableValue mark) {
		if (!mark.eIsSet(Literals.MARK_VARIABLE_VALUE__TIME) &&
			!mark.eIsSet(Literals.MARK_VARIABLE_VALUE__UNIT)) {
			return
		}
		if (!mark.eIsSet(Literals.MARK_VARIABLE_VALUE__UNIT)) {
			error('Remember to add unit: ' + TIME_UNIT_S.SECOND + ', ' + TIME_UNIT_S.MINUTE + ', ' + TIME_UNIT_S.HOUR,
				(Literals.MARK_VARIABLE_VALUE__TIME), INVALID_VALUE)
			return
		}

		val time = mark.time
		if (time < 1) {
			error('The time to finish should be>= 1', (Literals.MARK_VARIABLE_VALUE__TIME), INVALID_VALUE)
			return
		}
	}

	@Check
	def checkConditionDeviceValues(ConditionDevice condition) {
		if (!condition.eIsSet(Literals.CONDITION_DEVICE__DEVICE) ||
			!condition.eIsSet(Literals.CONDITION_DEVICE__DEVICE_VALUE)) {
			return
		}

		val device = condition.device
		val value = condition.deviceValue.value

		switch (device) {
			case device instanceof Crane: {
				if (value instanceof DiskStateValueS) {
					error(device.name + ' cannot be compared to disk states', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				if (value instanceof ColorValueS) {
					error(device.name + ' cannot be compared to colors', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				return
			}
			case device instanceof Disk: {
				if (value instanceof ColorValueS) {
					error(device.name + ' cannot be compared to colors', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				if (value instanceof DiskSlotStateValueS) {
					error(device.name + ' cannot be compared to disk slot states', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				return
			}
			case device instanceof Camera: {
				if (value instanceof DiskStateValueS) {
					error(device.name + ' cannot be compared to disk states', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				if (value instanceof ColorValueS) {
					error(device.name + ' cannot be compared to colors', Literals.CONDITION_DEVICE__DEVICE_VALUE,
						INVALID_VALUE)
					return
				}
				return
			}
		}
	}
	
	@Check
	def checkConditionVariableValues(ConditionVariable condition) {
		if (!condition.eIsSet(Literals.CONDITION_VARIABLE__VARIABLE) ||
			!condition.eIsSet(Literals.CONDITION_VARIABLE__VARIABLE_VALUE)) {
			return
		}

		val variable = condition.variable
		val value = condition.variableValue.value

		switch (variable) {
			case variable instanceof OrdinaryVariable: {
				if (value instanceof DiskStateValueS) {
					error(variable.name + ' cannot be compared to disk states', Literals.CONDITION_VARIABLE__VARIABLE_VALUE,
						INVALID_VALUE)
					return
				}
				if (value instanceof DiskSlotStateValueS) {
					error(variable.name + ' cannot be compared to disk slot states', Literals.CONDITION_VARIABLE__VARIABLE_VALUE,
						INVALID_VALUE)
					return
				}
				return
			}
			case variable instanceof SlotVariable: {
				if (value instanceof DiskStateValueS) {
					error(variable.name + ' cannot be compared to disk states', Literals.CONDITION_VARIABLE__VARIABLE_VALUE,
						INVALID_VALUE)
					return
				}
				return
			}
		}
	}
}
